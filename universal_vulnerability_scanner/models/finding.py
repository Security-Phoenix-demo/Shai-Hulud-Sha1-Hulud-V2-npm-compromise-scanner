#!/usr/bin/env python3
"""
Finding Data Model
Represents a security finding from vulnerability scanning
"""

from dataclasses import dataclass, field, asdict
from enum import Enum
from typing import List, Optional, Dict, Any
from datetime import datetime


class Verdict(Enum):
    """Verdict for a scanned package version."""
    VULNERABLE = "VULNERABLE"  # Confirmed vulnerable version
    SAFE = "SAFE"              # Confirmed safe version of vulnerable package
    CLEAN = "CLEAN"            # Not in vulnerability database
    REVIEW = "REVIEW"          # Needs manual review (unparseable, etc.)
    FIXED = "FIXED"            # Fixed version


class Severity(Enum):
    """Severity levels aligned with Phoenix Security platform."""
    CRITICAL = "CRITICAL"  # 10.0 - Confirmed exploit
    HIGH = "HIGH"          # 8.0 - Potentially compromised
    MEDIUM = "MEDIUM"      # 6.0 - Suspicious
    LOW = "LOW"            # 3.5 - Low risk
    INFO = "INFO"          # 1.0 - Informational
    

@dataclass
class Finding:
    """
    Represents a security finding from scanning.
    
    Attributes:
        path: File path where package was found
        kind: Type of file (package.json, package-lock.json, etc.)
        package: Package name
        version: Package version
        verdict: Verdict enum (VULNERABLE, SAFE, etc.)
        reason: Human-readable explanation
        severity: Severity level
        vulnerable_versions: List of known vulnerable versions
        safe_version: Recommended safe version
        cve_ids: CVE identifiers if available
        repository: Repository URL
        timestamp: When finding was created
    """
    path: str
    kind: str
    package: str
    version: str
    verdict: Verdict
    reason: str
    severity: Severity = Severity.INFO
    vulnerable_versions: List[str] = field(default_factory=list)
    safe_version: Optional[str] = None
    cve_ids: List[str] = field(default_factory=list)
    repository: Optional[str] = None
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert finding to dictionary."""
        data = asdict(self)
        data['verdict'] = self.verdict.value
        data['severity'] = self.severity.value
        return data
    
    def to_phoenix_format(self) -> Dict[str, Any]:
        """
        Convert finding to Phoenix Security platform format.
        
        Returns:
            Dict compatible with Phoenix API /v1/import/assets endpoint
        """
        # Map severity to Phoenix 1-10 scale
        severity_map = {
            Severity.CRITICAL: 10.0,
            Severity.HIGH: 8.0,
            Severity.MEDIUM: 6.0,
            Severity.LOW: 3.5,
            Severity.INFO: 1.0
        }
        
        phoenix_severity = severity_map.get(self.severity, 5.0)
        
        # Build description
        if self.verdict == Verdict.VULNERABLE:
            description = f"VULNERABLE: {self.package}@{self.version} - {self.reason}"
        elif self.verdict == Verdict.SAFE:
            description = f"SAFE: {self.package}@{self.version} is a safe version"
        elif self.verdict == Verdict.CLEAN:
            description = f"CLEAN: {self.package}@{self.version} not in vulnerability database"
        else:
            description = f"{self.verdict.value}: {self.package}@{self.version} - {self.reason}"
        
        # Build remedy
        if self.verdict == Verdict.VULNERABLE and self.safe_version:
            remedy = f"ğŸš¨ CRITICAL: Upgrade {self.package} to safe version {self.safe_version} or later. "
            remedy += f"Avoid vulnerable versions: {', '.join(self.vulnerable_versions[:5])}"
        elif self.verdict == Verdict.VULNERABLE:
            remedy = f"ğŸš¨ CRITICAL: Remove or replace {self.package}. All detected versions are vulnerable."
        elif self.verdict == Verdict.REVIEW:
            remedy = f"âš ï¸ REVIEW: Manual inspection required for {self.package}@{self.version}. {self.reason}"
        else:
            remedy = f"âœ… No action required. {self.package}@{self.version} is not vulnerable."
        
        return {
            "name": f"Vulnerability: {self.package}@{self.version}",
            "description": description,
            "remedy": remedy,
            "severity": f"{phoenix_severity:.1f}",
            "location": f"{self.package}@{self.version} in {self.path}",
            "publishedDateTime": self.timestamp,
            "referenceIds": self.cve_ids,
            "cwes": ["CWE-1104"],  # Use of Untrusted Inputs in a Security Decision
            "tags": [
                {"value": "supply-chain"},
                {"value": "vulnerability-scan"},
                {"value": f"verdict-{self.verdict.value.lower()}"}
            ],
            "packages": [{"name": self.package, "version": self.version}],
            "details": {
                "package_name": self.package,
                "package_version": self.version,
                "verdict": self.verdict.value,
                "severity": self.severity.value,
                "vulnerable_versions": self.vulnerable_versions,
                "safe_version": self.safe_version,
                "file_path": self.path,
                "file_type": self.kind,
                "repository": self.repository,
                "scan_tool": "Universal Vulnerability Scanner v1.0",
                "scan_timestamp": self.timestamp
            }
        }
    
    def __str__(self) -> str:
        """Human-readable string representation."""
        return f"[{self.verdict.value}] {self.package}@{self.version} in {self.path} - {self.reason}"


