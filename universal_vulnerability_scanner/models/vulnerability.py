#!/usr/bin/env python3
"""
Vulnerability Database Models
Defines vulnerability data structures and database management
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
import json
from pathlib import Path


@dataclass
class VulnerableRange:
    """Represents a range of vulnerable versions."""
    min_version: str  # Inclusive
    max_version: str  # Exclusive
    severity: str = "CRITICAL"
    
    def __str__(self) -> str:
        return f"[{self.min_version}, {self.max_version})"


@dataclass
class Vulnerability:
    """
    Represents a vulnerability entry for a package.
    
    Attributes:
        package_name: Name of the vulnerable package
        ecosystem: Package ecosystem (npm, pypi, rubygems, etc.)
        vulnerable_ranges: List of vulnerable version ranges
        safe_versions: List of known safe version patterns
        cve_ids: CVE identifiers
        description: Human-readable description
        references: URLs to advisories, patches, etc.
    """
    package_name: str
    ecosystem: str
    vulnerable_ranges: List[VulnerableRange] = field(default_factory=list)
    exact_vulnerable_versions: List[str] = field(default_factory=list)
    safe_versions: List[str] = field(default_factory=list)
    cve_ids: List[str] = field(default_factory=list)
    description: str = ""
    references: List[str] = field(default_factory=list)
    
    def is_vulnerable(self, version: str) -> Tuple[bool, str]:
        """
        Check if a given version is vulnerable.
        
        Args:
            version: Version string to check
            
        Returns:
            Tuple of (is_vulnerable: bool, reason: str)
        """
        from ..core.version_parser import is_in_range, semver_eq
        
        # Check exact matches first
        for vuln_ver in self.exact_vulnerable_versions:
            if semver_eq(version, vuln_ver):
                return True, f"Exact match with known vulnerable version {vuln_ver}"
        
        # Check ranges
        for vuln_range in self.vulnerable_ranges:
            if is_in_range(version, vuln_range.min_version, vuln_range.max_version):
                reason = f"Version {version} is in vulnerable range {vuln_range}"
                return True, reason
        
        return False, f"Version {version} not in known vulnerable versions"
    
    def get_safe_version_recommendation(self) -> Optional[str]:
        """Get recommended safe version."""
        if self.safe_versions:
            return self.safe_versions[0]
        
        # Calculate from vulnerable versions
        from ..core.version_parser import calculate_safe_version
        
        all_vulnerable = self.exact_vulnerable_versions.copy()
        for vr in self.vulnerable_ranges:
            all_vulnerable.append(vr.min_version)
        
        return calculate_safe_version(all_vulnerable) if all_vulnerable else None


class VulnerabilityDatabase:
    """
    Manages vulnerability database with multiple ecosystems.
    """
    
    def __init__(self, db_path: Optional[Path] = None):
        """
        Initialize vulnerability database.
        
        Args:
            db_path: Path to JSON database file
        """
        self.db_path = db_path
        self.vulnerabilities: Dict[str, Dict[str, Vulnerability]] = {}
        self.metadata: Dict[str, str] = {}
        
        if db_path and db_path.exists():
            self.load_from_file(db_path)
    
    def load_from_file(self, path: Path):
        """Load vulnerability database from JSON file."""
        with open(path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        self.metadata = data.get('metadata', {})
        
        for ecosystem, packages in data.get('vulnerabilities', {}).items():
            if ecosystem not in self.vulnerabilities:
                self.vulnerabilities[ecosystem] = {}
            
            for pkg_name, vuln_data in packages.items():
                # Parse ranges
                ranges = []
                for range_data in vuln_data.get('vulnerable_ranges', []):
                    ranges.append(VulnerableRange(
                        min_version=range_data['min'],
                        max_version=range_data['max'],
                        severity=range_data.get('severity', 'CRITICAL')
                    ))
                
                # Create vulnerability
                vuln = Vulnerability(
                    package_name=pkg_name,
                    ecosystem=ecosystem,
                    vulnerable_ranges=ranges,
                    exact_vulnerable_versions=vuln_data.get('exact_versions', []),
                    safe_versions=vuln_data.get('safe_versions', []),
                    cve_ids=vuln_data.get('cve_ids', []),
                    description=vuln_data.get('description', ''),
                    references=vuln_data.get('references', [])
                )
                
                self.vulnerabilities[ecosystem][pkg_name] = vuln
    
    def check_package(self, package_name: str, version: str, ecosystem: str = 'npm') -> Tuple[bool, Optional[Vulnerability], str]:
        """
        Check if a package version is vulnerable.
        
        Args:
            package_name: Name of package
            version: Version string
            ecosystem: Package ecosystem (default: npm)
            
        Returns:
            Tuple of (is_vulnerable, vulnerability_obj, reason)
        """
        if ecosystem not in self.vulnerabilities:
            return False, None, f"Ecosystem {ecosystem} not in database"
        
        if package_name not in self.vulnerabilities[ecosystem]:
            return False, None, f"Package {package_name} not in vulnerability database"
        
        vuln = self.vulnerabilities[ecosystem][package_name]
        is_vuln, reason = vuln.is_vulnerable(version)
        
        return is_vuln, vuln if is_vuln else None, reason
    
    def get_vulnerability(self, package_name: str, ecosystem: str = 'npm') -> Optional[Vulnerability]:
        """Get vulnerability entry for a package."""
        return self.vulnerabilities.get(ecosystem, {}).get(package_name)
    
    def get_stats(self) -> Dict[str, int]:
        """Get database statistics."""
        stats = {
            'total_vulnerabilities': 0,
            'ecosystems': len(self.vulnerabilities)
        }
        
        for ecosystem, packages in self.vulnerabilities.items():
            stats['total_vulnerabilities'] += len(packages)
            stats[f'{ecosystem}_packages'] = len(packages)
        
        return stats
    
    def __str__(self) -> str:
        stats = self.get_stats()
        return f"VulnerabilityDatabase: {stats['total_vulnerabilities']} vulnerabilities across {stats['ecosystems']} ecosystems"


