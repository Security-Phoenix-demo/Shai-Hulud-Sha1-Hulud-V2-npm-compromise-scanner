#!/usr/bin/env python3
"""
Semantic Version Parser
Robust semver parsing and comparison, adapted from react/rsc_exposure_scanner.py
Handles NPM version ranges, pre-releases, and build metadata per semver.org spec
"""

import re
from typing import Optional, Tuple, List

# Semver regex pattern (from semver.org specification)
SEMVER_RE = re.compile(
    r"^(?P<maj>0|[1-9]\d*)\.(?P<min>0|[1-9]\d*)\.(?P<pat>0|[1-9]\d*)"
    r"(?:-(?P<pre>[0-9A-Za-z.-]+))?"
    r"(?:\+(?P<build>[0-9A-Za-z.-]+))?$"
)


def parse_semver(v: str) -> Optional[Tuple[int, int, int, str]]:
    """
    Parse semantic version string into components.
    
    Args:
        v: Version string (e.g., "1.2.3", "1.2.3-beta.1", "1.2.3+build123")
    
    Returns:
        Tuple of (major, minor, patch, prerelease) or None if invalid
        
    Examples:
        >>> parse_semver("1.2.3")
        (1, 2, 3, "")
        >>> parse_semver("2.0.0-rc.1")
        (2, 0, 0, "rc.1")
    """
    v = v.strip()
    m = SEMVER_RE.match(v)
    if not m:
        return None
    
    maj = int(m.group("maj"))
    mi = int(m.group("min"))
    pa = int(m.group("pat"))
    pre = m.group("pre") or ""
    
    return (maj, mi, pa, pre)


def semver_lt(a: str, b: str) -> bool:
    """
    Compare if version a < version b (less than).
    
    Args:
        a: First version string
        b: Second version string
        
    Returns:
        True if a < b, False otherwise
        
    Examples:
        >>> semver_lt("1.0.0", "1.0.1")
        True
        >>> semver_lt("2.0.0", "1.9.9")
        False
    """
    pa = parse_semver(a)
    pb = parse_semver(b)
    
    if not pa or not pb:
        # If unparseable, avoid false confidence
        return False
    
    a_key = (pa[0], pa[1], pa[2])
    b_key = (pb[0], pb[1], pb[2])
    
    if a_key != b_key:
        return a_key < b_key
    
    # Pre-release is considered lower than stable if same core numbers
    # e.g., 1.0.0-beta < 1.0.0
    return (pa[3] != "" and pb[3] == "")


def semver_gte(a: str, b: str) -> bool:
    """
    Compare if version a >= version b (greater than or equal).
    
    Args:
        a: First version string
        b: Second version string
        
    Returns:
        True if a >= b, False otherwise
    """
    return not semver_lt(a, b)


def semver_eq(a: str, b: str) -> bool:
    """
    Compare if version a == version b (equal).
    
    Args:
        a: First version string
        b: Second version string
        
    Returns:
        True if a == b, False otherwise
    """
    pa = parse_semver(a)
    pb = parse_semver(b)
    
    if not pa or not pb:
        return False
    
    return pa == pb


def is_in_range(v: str, lo: str, hi: str) -> bool:
    """
    Check if version is in range [lo, hi) (inclusive lo, exclusive hi).
    
    Args:
        v: Version to check
        lo: Lower bound (inclusive)
        hi: Upper bound (exclusive)
        
    Returns:
        True if lo <= v < hi, False otherwise
        
    Examples:
        >>> is_in_range("1.0.5", "1.0.0", "1.1.0")
        True
        >>> is_in_range("1.1.0", "1.0.0", "1.1.0")
        False
    """
    return semver_gte(v, lo) and semver_lt(v, hi)


def normalize_version(v: str) -> Optional[str]:
    """
    Convert NPM-style version specifiers to concrete semver.
    
    Handles:
    - Exact versions: "1.2.3"
    - v-prefix: "v1.2.3"
    - Caret: "^1.2.3" -> "1.2.3"
    - Tilde: "~1.2.3" -> "1.2.3"
    - Equals: "=1.2.3" -> "1.2.3"
    
    Rejects:
    - Ranges: ">=1.0.0", "1.0.0 - 2.0.0"
    - Wildcards: "*", "1.x", "1.2.x"
    - Special: "workspace:", "file:", "git+https://"
    
    Args:
        v: Version specifier string
        
    Returns:
        Normalized version string or None if not normalizable
        
    Examples:
        >>> normalize_version("^1.2.3")
        "1.2.3"
        >>> normalize_version(">=1.0.0")
        None
    """
    v = v.strip()
    v = v.lstrip("v")
    v = re.sub(r"^[\^~=\s]+", "", v)
    
    # Reject obvious ranges and special specifiers
    reject_tokens = [">", "<", "||", "*", "x", "X", "workspace:", "file:", "git+", "http:", "https:"]
    if any(tok in v for tok in reject_tokens):
        return None
    
    return v if parse_semver(v) else None


def calculate_safe_version(vulnerable_versions: List[str]) -> str:
    """
    Calculate a safe version (one version before the first compromised).
    
    Args:
        vulnerable_versions: List of vulnerable version strings
        
    Returns:
        Suggested safe version string
        
    Examples:
        >>> calculate_safe_version(["1.0.5", "1.0.6"])
        "1.0.4"
        >>> calculate_safe_version(["2.0.0"])
        "1.99.99"
    """
    if not vulnerable_versions:
        return "unknown - check release history"
    
    try:
        # Sort versions to find the earliest
        sorted_versions = sorted(vulnerable_versions, key=lambda x: parse_semver(x) or (0, 0, 0, ""))
        first_ver = sorted_versions[0]
        parsed = parse_semver(first_ver)
        
        if not parsed:
            return "check manually"
        
        major, minor, patch, _ = parsed
        
        if patch > 0:
            return f"{major}.{minor}.{patch-1}"
        elif minor > 0:
            return f"{major}.{minor-1}.99"
        elif major > 0:
            return f"{major-1}.99.99"
        
        return "0.0.0 or avoid package"
        
    except Exception as e:
        return f"check manually (error: {e})"


if __name__ == "__main__":
    # Quick self-test
    print("ðŸ§ª Testing version parser...")
    
    # Test parsing
    assert parse_semver("1.2.3") == (1, 2, 3, "")
    assert parse_semver("2.0.0-rc.1") == (2, 0, 0, "rc.1")
    
    # Test comparison
    assert semver_lt("1.0.0", "1.0.1") == True
    assert semver_lt("2.0.0", "1.9.9") == False
    assert semver_gte("1.0.1", "1.0.0") == True
    
    # Test range
    assert is_in_range("19.1.0", "19.0.0", "19.1.2") == True
    assert is_in_range("19.1.2", "19.0.0", "19.1.2") == False
    
    # Test normalization
    assert normalize_version("^1.2.3") == "1.2.3"
    assert normalize_version("~2.0.0") == "2.0.0"
    assert normalize_version(">=1.0.0") is None
    
    print("âœ… All tests passed!")

