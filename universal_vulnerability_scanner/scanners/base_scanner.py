#!/usr/bin/env python3
"""
Base Scanner Abstract Class
Defines interface for all ecosystem scanners
"""

from abc import ABC, abstractmethod
from pathlib import Path
from typing import List, Dict, Optional
from ..models.finding import Finding
from ..models.vulnerability import VulnerabilityDatabase


class BaseScanner(ABC):
    """Abstract base class for vulnerability scanners."""
    
    def __init__(self, vulnerability_db: VulnerabilityDatabase):
        """
        Initialize scanner with vulnerability database.
        
        Args:
            vulnerability_db: Loaded vulnerability database
        """
        self.vulnerability_db = vulnerability_db
        self.ecosystem = self._get_ecosystem()
    
    @abstractmethod
    def _get_ecosystem(self) -> str:
        """Return the ecosystem name (npm, pypi, rubygems, etc.)"""
        pass
    
    @abstractmethod
    def scan_path(self, root: Path) -> List[Finding]:
        """
        Scan a directory tree for vulnerabilities.
        
        Args:
            root: Root directory to scan
            
        Returns:
            List of Finding objects
        """
        pass
    
    @abstractmethod
    def parse_manifest(self, file_path: Path) -> Dict[str, str]:
        """
        Parse a manifest file (package.json, requirements.txt, etc.).
        
        Args:
            file_path: Path to manifest file
            
        Returns:
            Dictionary of {package_name: version_spec}
        """
        pass
    
    @abstractmethod
    def parse_lockfile(self, file_path: Path) -> Dict[str, str]:
        """
        Parse a lockfile (package-lock.json, Pipfile.lock, etc.).
        
        Args:
            file_path: Path to lockfile
            
        Returns:
            Dictionary of {package_name: resolved_version}
        """
        pass
    
    def check_vulnerability(self, package_name: str, version: str, file_path: str, file_kind: str) -> Optional[Finding]:
        """
        Check if a package version is vulnerable.
        
        Args:
            package_name: Package name
            version: Version string
            file_path: Where package was found
            file_kind: Type of file (manifest, lockfile, etc.)
            
        Returns:
            Finding object if relevant, None otherwise
        """
        from ..core.version_parser import normalize_version
        from ..models.finding import Verdict, Severity
        
        # Normalize version
        normalized = normalize_version(version)
        if not normalized:
            # Can't normalize - needs review
            return Finding(
                path=file_path,
                kind=file_kind,
                package=package_name,
                version=version,
                verdict=Verdict.REVIEW,
                reason=f"Could not normalize version specifier '{version}'",
                severity=Severity.LOW
            )
        
        # Check against vulnerability database
        is_vuln, vuln, reason = self.vulnerability_db.check_package(
            package_name, normalized, self.ecosystem
        )
        
        if is_vuln and vuln:
            # VULNERABLE
            return Finding(
                path=file_path,
                kind=file_kind,
                package=package_name,
                version=normalized,
                verdict=Verdict.VULNERABLE,
                reason=reason,
                severity=Severity.CRITICAL,
                vulnerable_versions=vuln.exact_vulnerable_versions,
                safe_version=vuln.get_safe_version_recommendation(),
                cve_ids=vuln.cve_ids
            )
        
        # Check if package is in database but version is safe
        vuln_entry = self.vulnerability_db.get_vulnerability(package_name, self.ecosystem)
        if vuln_entry:
            # Package is vulnerable but this version is safe
            return Finding(
                path=file_path,
                kind=file_kind,
                package=package_name,
                version=normalized,
                verdict=Verdict.SAFE,
                reason=f"Safe version of monitored package (vulnerable versions: {', '.join(vuln_entry.exact_vulnerable_versions[:3])})",
                severity=Severity.INFO,
                vulnerable_versions=vuln_entry.exact_vulnerable_versions,
                safe_version=normalized,
                cve_ids=vuln_entry.cve_ids
            )
        
        # Not in database - clean
        return Finding(
            path=file_path,
            kind=file_kind,
            package=package_name,
            version=normalized,
            verdict=Verdict.CLEAN,
            reason="Package not in vulnerability database",
            severity=Severity.INFO
        )


