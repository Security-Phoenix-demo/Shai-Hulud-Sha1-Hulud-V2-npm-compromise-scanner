#!/usr/bin/env python3
"""
NPM Scanner
Scans package.json, package-lock.json, yarn.lock, and pnpm-lock.yaml
Adapted from react/rsc_exposure_scanner.py with enhancements
"""

import json
import os
import re
from pathlib import Path
from typing import Dict, List
from .base_scanner import BaseScanner
from ..models.finding import Finding


class NPMScanner(BaseScanner):
    """Scanner for NPM ecosystem (Node.js packages)."""
    
    def _get_ecosystem(self) -> str:
        return "npm"
    
    def scan_path(self, root: Path) -> List[Finding]:
        """
        Recursively scan directory for NPM package files.
        
        Scans:
        - package.json (direct dependencies)
        - package-lock.json (resolved versions)
        - yarn.lock (yarn resolved versions)
        - pnpm-lock.yaml (pnpm resolved versions)
        """
        findings: List[Finding] = []
        
        for dirpath, _, filenames in os.walk(root):
            dp = Path(dirpath)
            
            # Skip node_modules
            if 'node_modules' in dp.parts:
                continue
            
            # package.json (direct deps)
            if "package.json" in filenames:
                pj = dp / "package.json"
                try:
                    deps = self.parse_manifest(pj)
                    for pkg, version_spec in deps.items():
                        finding = self.check_vulnerability(pkg, version_spec, str(pj), "package.json")
                        if finding:
                            findings.append(finding)
                except Exception as e:
                    from ..models.finding import Finding, Verdict, Severity
                    findings.append(Finding(
                        path=str(pj),
                        kind="package.json",
                        package="N/A",
                        version="N/A",
                        verdict=Verdict.REVIEW,
                        reason=f"Failed to parse: {e}",
                        severity=Severity.LOW
                    ))
            
            # package-lock.json (npm lockfile)
            if "package-lock.json" in filenames:
                pl = dp / "package-lock.json"
                try:
                    resolved = self.parse_lockfile(pl)
                    for pkg, version in resolved.items():
                        finding = self.check_vulnerability(pkg, version, str(pl), "package-lock.json")
                        if finding:
                            findings.append(finding)
                except Exception as e:
                    from ..models.finding import Finding, Verdict, Severity
                    findings.append(Finding(
                        path=str(pl),
                        kind="package-lock.json",
                        package="N/A",
                        version="N/A",
                        verdict=Verdict.REVIEW,
                        reason=f"Failed to parse: {e}",
                        severity=Severity.LOW
                    ))
            
            # yarn.lock
            if "yarn.lock" in filenames:
                yl = dp / "yarn.lock"
                try:
                    resolved = self._parse_yarn_lock(yl)
                    for pkg, version in resolved.items():
                        finding = self.check_vulnerability(pkg, version, str(yl), "yarn.lock")
                        if finding:
                            findings.append(finding)
                except Exception as e:
                    from ..models.finding import Finding, Verdict, Severity
                    findings.append(Finding(
                        path=str(yl),
                        kind="yarn.lock",
                        package="N/A",
                        version="N/A",
                        verdict=Verdict.REVIEW,
                        reason=f"Failed to parse: {e}",
                        severity=Severity.LOW
                    ))
            
            # pnpm-lock.yaml
            if "pnpm-lock.yaml" in filenames:
                pn = dp / "pnpm-lock.yaml"
                try:
                    resolved = self._parse_pnpm_lock(pn)
                    for pkg, version in resolved.items():
                        finding = self.check_vulnerability(pkg, version, str(pn), "pnpm-lock.yaml")
                        if finding:
                            findings.append(finding)
                except Exception as e:
                    from ..models.finding import Finding, Verdict, Severity
                    findings.append(Finding(
                        path=str(pn),
                        kind="pnpm-lock.yaml",
                        package="N/A",
                        version="N/A",
                        verdict=Verdict.REVIEW,
                        reason=f"Failed to parse: {e}",
                        severity=Severity.LOW
                    ))
        
        return findings
    
    def parse_manifest(self, file_path: Path) -> Dict[str, str]:
        """Parse package.json for dependencies."""
        data = json.loads(file_path.read_text(encoding="utf-8"))
        out = {}
        
        for section in ["dependencies", "devDependencies", "peerDependencies", "optionalDependencies"]:
            deps = data.get(section, {}) or {}
            for k, v in deps.items():
                out[k] = str(v)
        
        return out
    
    def parse_lockfile(self, file_path: Path) -> Dict[str, str]:
        """
        Parse package-lock.json (npm lockfile v1/v2/v3).
        
        Extracts resolved versions from lockfile.
        """
        data = json.loads(file_path.read_text(encoding="utf-8"))
        out = {}
        
        # npm v2/v3: "packages" object
        pkgs = data.get("packages")
        if isinstance(pkgs, dict):
            for p, meta in pkgs.items():
                if not isinstance(meta, dict):
                    continue
                
                name = meta.get("name")
                version = meta.get("version")
                
                # Handle scoped packages (@scope/name)
                if not name and p.startswith("node_modules/"):
                    path_parts = p.replace("node_modules/", "").split("/")
                    if path_parts[0].startswith("@") and len(path_parts) >= 2:
                        name = "/".join(path_parts[:2])
                    elif path_parts:
                        name = path_parts[0]
                
                if name and isinstance(version, str):
                    out[name] = version
        
        # npm v1: "dependencies" tree
        deps = data.get("dependencies")
        if isinstance(deps, dict):
            def walk(d: dict):
                for name, meta in d.items():
                    if not isinstance(meta, dict):
                        continue
                    version = meta.get("version")
                    if isinstance(version, str):
                        out[name] = version
                    child = meta.get("dependencies")
                    if isinstance(child, dict):
                        walk(child)
            walk(deps)
        
        return out
    
    def _parse_yarn_lock(self, file_path: Path) -> Dict[str, str]:
        """Parse yarn.lock file (best-effort, no YAML dependency)."""
        YARN_ENTRY_RE = re.compile(r'^(?P<key>.+):\s*$')
        YARN_VERSION_RE = re.compile(r'^\s*version\s+"(?P<ver>[^"]+)"\s*$')
        
        out = {}
        current_keys = []
        
        for line in file_path.read_text(encoding="utf-8", errors="ignore").splitlines():
            m1 = YARN_ENTRY_RE.match(line)
            if m1:
                current_keys = [k.strip().strip('"') for k in m1.group("key").split(",")]
                continue
            
            m2 = YARN_VERSION_RE.match(line)
            if m2 and current_keys:
                ver = m2.group("ver")
                for key in current_keys:
                    # key examples: "next@^15.0.0" or "@scope/pkg@^1.0.0"
                    if key.startswith("@"):
                        # Scoped package: split on last @
                        parts = key.rsplit("@", 1)
                        pkg = parts[0]
                    else:
                        pkg = key.split("@", 1)[0]
                    
                    out[pkg] = ver
                current_keys = []
        
        return out
    
    def _parse_pnpm_lock(self, file_path: Path) -> Dict[str, str]:
        """Parse pnpm-lock.yaml (best-effort, no YAML dependency)."""
        PNPM_PKG_RE = re.compile(r'^\s*/(?P<name>[^/]+)/(?P<ver>\d+\.\d+\.\d+(?:-[^ :]+)?)\s*:\s*$')
        PNPM_SCOPED_RE = re.compile(r'^\s*/(?P<scope>@[^/]+)/(?P<name>[^/]+)/(?P<ver>\d+\.\d+\.\d+(?:-[^ :]+)?)\s*:\s*$')
        
        out = {}
        
        for line in file_path.read_text(encoding="utf-8", errors="ignore").splitlines():
            # Try scoped package first
            m = PNPM_SCOPED_RE.match(line)
            if m:
                pkg = f"{m.group('scope')}/{m.group('name')}"
                ver = m.group("ver")
                out[pkg] = ver
                continue
            
            # Try regular package
            m = PNPM_PKG_RE.match(line)
            if m:
                pkg = m.group("name")
                ver = m.group("ver")
                out[pkg] = ver
        
        return out


